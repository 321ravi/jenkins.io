---
:layout: post
:title: "Introducing the Jenkins Templating Engine!"
:tags:
- general
- pipeline
- plugin
- pipeline-authoring
:author: Steven Terrana
:sig: pipeline-authoring
---

[NOTE]
====
This is a guest post by link:https://github.com/steven-terrana[Steven Terrana], a Lead Technologist at
link:https://boozallen.com[Booz Allen Hamilton], principal engineer working on the plugin:templating-engine[Templating Engine Plugin] and participating in the link:../../../../../sigs/pipeline-authoring[Pipeline Authoring  Special Interest Group]
====


Implementing DevSecOps practices at the enterprise scale is challenging. With multiple programming languages, automated testing frameworks, and security compliance tools being used by different applications within your organization it becomes difficult at best to build and maintain pipelines for each team. 

Most pipelines are going to follow the same generic workflow regardless of what specific tech stack is employed by an application.  The plugin:templating-engine[Templating Engine Plugin] (abbreviated as JTE for Jenkins Templating Engine) allows you to capture this efficiency by creating tool-agnostic, templated workflows to be reused by every team.  

As federal consultants, at Booz Allen we found ourselves starting from scratch every time we began a new project.  Through developing the Jenkins Templating Engine, weâ€™ve seen pipeline development decrease from months to days now that we can reuse tool integrations while at the same time bringing a new level of governance to Jenkins pipelines. 


= Pipeline Templating 

A common model I've encountered when supporting modern software development projects applications is the desire to let application developers focus on what they do best: building applications. This often results in a centralized DevOps team responsible for maintaining platform infrastructure and orchestrating CI/CD pipelines that the different development teams utilize while building their application.  

When utilizing a microservices-based architecture, this often means building and supporting a pipeline for many different development teams, all of whom may be leveraging different programming languages and automating testing tools.  

Regardless of what specific tools are being used, the workflow is likely going to be the same across these different teams: unit test, static code analysis, build and publish an artifact, deploy it, and then perform different types of testing against the deployed application. 

This is the fundamental idea of the Templating Engine Plugin: to be able to define the pipeline workflow abstractly to be reused by every team leveraging the workflow while still being flexible enough to support multiple tools at the same time. 

== In Practice

Let's walk through a bare bones template to demonstrate the reusability of templates: 

[pipeline]
----
// Script //
unit_test()
build()
static_code_analysis() 
----

The goal of a template is to read as close to plain English as possible while describing what the pipeline is going to do. Pipeline 
templates execute just like any other ``Jenkinsfile``, so scripted pipeline syntax is supported. Alongside the typical scripted 
pipeline syntax we have added some syntactic sugar to enable the templating functionality.

TIP: Leveraging templates in this way lets you separate the **business logic** (what should happen when) of your pipeline from the
**technical implementation** (what's actually going to happen).  The result of this is a CI/CD pipeline that's proven to be 
significantly easier to manage when supporting multiple teams simultaneously.  

The implementation of the steps invoked by this template, ``unit_test()``, ``build()``, and ``static_code_analysis()``, will come 
from a **Library**.  By naming these steps generically, different libraries can implement the same step.  With the functionality of
each step determined by the libraries implementation, multiple teams can reuse the __same__ pipeline template by choosing __different__ libraries
to load. 

== Shareable Pipeline Libraries & The Configuration File 

If pipeline templates are only responsible for specifying the business logic of the pipeline, then there must be something that
holds the underlying technical implementation of the steps called.  The Templating Engine Plugin has implemented a version of Jenkins
Shared Libraries that aims to enhance the reusability of libraries.  

=== Creating the Libraries 

In our example, the pipeline template needs to perform unit testing, package an artifact, and run static code analysis. 

To demonstrate the reusability of the template, let's assume that we have some applications using gradle and some 
applications using maven to build their application and they will both use SonarQube to perform static code analysis.  

In this case, we will need ``gradle``, ``maven``, and ``sonarqube`` libraries.  Libraries are just directories at the root of  
the source code repository configured via a Library Source.  Any groovy file within a Library directory will be loaded as a 
step invokable via the base filename. 

----
|- gradle/
  \-- build.groovy
  \-- unit_test.groovy
|- maven/
  \-- build.groovy
  \-- unit_test.groovy
|- sonarqube/
  \-- static_code_analysis.groovy 
----


=== Implementing Steps

Implementing library steps is exactly the same as just writing regular global variables as part of the default Jenkins Shared Libraries. 

For the purposes of this demonstration, we will just have each step print out the step name and contributing library. 

For example: 

.gradle/build.groovy
[source, groovy]
----
void call(){
    println "gradle: build()" 
} 
----

TIP: Read more about link:https://boozallen.github.io/jenkins-templating-engine/pages/Library_Development/index.html[Library Development within JTE].

=== Configuring the Pipeline 

We now have all the pieces we need to configure JTE and two applications using the same pipeline template. 

**Step 1: Configure a link:https://boozallen.github.io/jenkins-templating-engine/pages/Governance/index.html#governance-tier[Governance Tier]**

[TIP]
====
----
A Governance Tier holds three things: 
    1: Pipeline Templates
    2: The tier's configuration file (pipeline_config.groovy)
    3: A list of Library Sources

Through the Templating Engine, you can create a pipeline governance hierarchy matching your organization's
taxonomy by representing this structure via folders in Jenkins. 
----
====


image:/images/post-images/2019-04-05-templating-engine/governance_tier.png[role=center]

For this example, the example Governance Tier has two necessary files: 

.pipeline_config.groovy
[source, groovy]
----
/*
  specify which libraries to load: 
    In the Governance Tier configuration file, 
    these should be configurations common across 
    all apps governed by this config. 
*/
libraries{
  merge = true // allow individual apps to contribute additional libraries
  sonarqube
}
----

.Jenkinsfile
[source, groovy]
----
/*
    A Governance Tier Jenkinsfile will serve
    as the default template for the tier. Named templates
    may exist in a pipeline_templates directory 
*/
unit_test()
build()
static_code_analysis() 
----

**Step 2: Create a Multibranch Pipeline for Both Applications** 

Sample repositories have been created for a link:https://github.com/steven-terrana/example-jte-app-maven[Maven application] 
and a link:https://github.com/steven-terrana/example-jte-app-gradle[Gradle application]. 

When creating the Multibranch Pipeline Projects for each app, the Templating Engine plugin supplies a new ``Project Recognizer`` 
called **Jenkins Templating Engine**.  This sets the project to use the Templating Engine framework for all branches within the
repository.  

These repositories both contain an application ``pipeline_config.groovy`` configuration file. 

.maven app: pipeline_config.groovy
[source, groovy]
----
libraries{
    maven
}
----

.gradle app: pipeline_config.groovy
[source, groovy]
----
libraries{
    gradle
}
----

**Step 3: Run the Pipelines** 

That's it!  Now, both applications will leverage the exact same pipeline template while having the flexibility to select which 
tools should be used during each phase of the pipeline. 

Below is sample output from the console log for both applications pipeline runs: 

**Gradle:** 
----
[JTE] Obtained Template Configuration File pipeline_config.groovy from git https://github.com/steven-terrana/example-jte-configuration
[JTE] Obtained Template Configuration File pipeline_config.groovy from git https://github.com/steven-terrana/example-jte-app-gradle.git
[JTE] Loading Library sonarqube from git https://github.com/steven-terrana/example-jte-libraries.git
[JTE] Loading Library gradle from git https://github.com/steven-terrana/example-jte-libraries.git
...
[JTE] Obtained Template Jenkinsfile from git https://github.com/steven-terrana/example-jte-configuration
[JTE][Step - gradle/unit_test]
[Pipeline] echo
gradle: unit_test()
[JTE][Step - gradle/build]
[Pipeline] echo
gradle: build()
[JTE][Step - sonarqube/static_code_analysis]
[Pipeline] echo
sonarqube: static_code_analysis()
[Pipeline] End of Pipeline
----

**Maven:**
----
[JTE] Obtained Template Configuration File pipeline_config.groovy from git https://github.com/steven-terrana/example-jte-configuration
[JTE] Obtained Template Configuration File pipeline_config.groovy from git https://github.com/steven-terrana/example-jte-app-maven.git
[JTE] Loading Library sonarqube from git https://github.com/steven-terrana/example-jte-libraries.git
[JTE] Loading Library maven from git https://github.com/steven-terrana/example-jte-libraries.git
...
[JTE] Obtained Template Jenkinsfile from git https://github.com/steven-terrana/example-jte-configuration
[JTE][Step - maven/unit_test]
[Pipeline] echo
maven: unit_test()
[JTE][Step - maven/build]
[Pipeline] echo
maven: build()
[JTE][Step - sonarqube/static_code_analysis]
[Pipeline] echo
sonarqube: static_code_analysis()
[Pipeline] End of Pipeline
----


= The Benefits of the Templating Engine 

image:/images/post-images/2019-04-05-templating-engine/jte_benefits.png[role=center]

== Organizational Governance

Leveraging the Templating Engine Plugin will allow you to define enterprise scale approved 
workflows that can be used by teams regardless of what tools are being used.  This top-down 
approach makes scaling and enforcing DevSecOps principles significantly easier within your organization.  

== Optimize Code Reuse

There's really no need for every team in your organization to figure out how to do the same things over
and over again.  At Booz Allen, we have seen pipeline development time decrease from months to days as 
we continuously reuse and expand upon our Templating Engine library portfolio as part of our Solutions
Delivery Platform. 

== Simplify Pipeline Maintainability

Often DevOps engineers find themselves building and supporting pipelines for multiple development teams at
the same time.  By decoupling the workflow from the technical implementation and consolidating the pipeline 
definition to a centralized location, the Templating Engine plugin allows DevOps engineers to scale much faster. 

= Advanced Features 

* link:https://boozallen.github.io/jenkins-templating-engine/pages/Governance/conditional_inheritance.html[Configuration File Conditional Inheritance]
* link:https://boozallen.github.io/jenkins-templating-engine/pages/Library_Development/externalizing_config.html[Externalize Library Configurations]
* link:https://boozallen.github.io/jenkins-templating-engine/pages/Library_Development/lifecycle_hooks.html[Aspect Oriented LifeCycle Hooks]
* link:https://boozallen.github.io/jenkins-templating-engine/pages/Governance/index.html#pipeline-template-selection[Multiple Pipeline Templates]
* link:https://boozallen.github.io/jenkins-templating-engine/pages/Templating/configuration_files/default_step_implementation.html[Default Step Implementation]
* link:https://boozallen.github.io/jenkins-templating-engine/pages/Templating/configuration_files/sandboxing.html[Configuration File DSL Sandboxing]

= More Resources

== For this Demonstration 

* link:https://github.com/steven-terrana/example-jte-configuration[Pipeline Configuration Repository]
* link:https://github.com/steven-terrana/example-jte-libraries[Sample Libraries]
* link:https://github.com/steven-terrana/example-jte-app-maven[Sample Maven Repository]
* link:https://github.com/steven-terrana/example-jte-app-gradle[Sample Gradle Repository]

== Additional Resources
* link:https://boozallen.github.io/jenkins-templating-engine/[Templating Engine Documentation]
* link:https://github.com/jenkinsci/templating-engine-plugin[Source Code]
* link:https://github.com/boozallen/sdp-libraries[Booz Allen's SDP Pipeline Libraries]
* link:https://boozallen.com[Booz Allen Hamilton]



