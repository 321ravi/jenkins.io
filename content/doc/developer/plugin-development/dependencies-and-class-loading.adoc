---
title: Dependencies and Class Loading
summary: How code is physically structured in Jenkins core and plugins, and how this relates to dependencies and Java class loading behavior.
layout: developersection
---

Jenkins has a complex, modular architecture.
To enable plugins to use the rich array of libraries available in the Java ecosystem,
and build on one another using plugin-to-plugin APIs,
the Jenkins plugin extension mechanism goes beyond simple plugin manifests.

The de facto build tool for Jenkins plugins is Apache Maven.
All examples here will use Maven.
Building plugins using Gradle is also possible but particular capabilities may lag behind.

## Jenkins class loading

Before diving into _how_ to refer to libraries and other plugins from your plugin,
it is useful to understand the elements of Java class loading and how that applies to Jenkins.
If you are not a Java developer, you can get away with ignoring all this for simple plugins,
but will need to understand class loading to troubleshoot strange errors or perform advanced packaging.

### The plugin class loader hierarchy

[source]
----
□ Java Platform
 ↖
  □ “application classpath” (servlet container): java -jar jenkins.war
   ↖
    □ Jenkins core: jenkins.war!/WEB-INF/lib/*.jar
     ↖
      □ plugin A: $JENKINS_HOME/plugins/a.jpi!/WEB-INF/lib/*.jar
       ↖                                                             ↖
        □ plugin C: $JENKINS_HOME/plugins/c.jpi!/WEB-INF/lib/*.jar  ← □ UberClassLoader
     ↖ ↙                                                             ↙
      □ plugin B: $JENKINS_HOME/plugins/b.jpi!/WEB-INF/lib/*.jar
      ⋮
----

Java class loaders have _parents_ to which they delegate.
For purposes of Jenkins, what matters most is that “Jenkins core” delegates to the Java Platform,
and Jenkins plugins all delegate to Jenkins core.

Plugins may also delegate to one another.
In the above example, C declares dependencies on A and B.
In its +c.jpi!/META-INF/MANIFEST.MF+ this would look something like:

[source]
----
Plugin-Dependencies: a:1.13,b:1.6
----

Thus C can directly refer to classes defined in either A or B, as well as to Jenkins and the Java Platform:

[source,java]
----
package org.jenkinsci.plugins.c;
import java.util.Date;
import jenkins.model.Jenkins;
import org.jenkinsci.plugins.a.Alpha;
import org.jenkinsci.plugins.b.Beta;
public class Charlie {/* … */}
----

Each (enabled) plugin gets its own +ClassLoader+.
It is possible for two distinct plugins to define a class of the same name, so long as neither depends on the other.

There is also a single special +UberClassLoader+ which delegates to _all_ enabled plugins.
This never loads any additional resources but it can be used to look up any plugin class or resource.

### Initiating vs. defining loaders

When you _initiate_ loading of a class

[source,java]
----
Class<?> alpha = Charlie.class.getClassLoader().loadClass("org.jenkinsci.plugins.a.Alpha");
----

you are asking a particular +ClassLoader+ (here, C’s) to look up a class by name.
(Normally this will _start_ by asking all of its parents to find that class,
and only look in `c.jpi!/WEB-INF/lib/*.jar` as a last resort.)

What happens if +Alpha.class+ refers to various other classes, for example by using them in +import+ statements?
Java considers the _defining_ loader of +Alpha.class+ (A’s), and only asks that class loader.
The fact that you started loading in C is irrelevant.
This means that C cannot provide some class A might need to link against.
A needs to be able to “see” any such class on its own.
Otherwise you will get a +NoClassDefFoundError+ at runtime.

### Context class loaders

Java defines a +Thread.getContextClassLoader()+.
Jenkins does not use this much; it will normally be set by the servlet container to the Jenkins core loader.

Some Java libraries have a fundamental design flaw, originating in premodular systems with a “flat classpath”,
whereby they expect classes defined by clients of the library to be available by name without any qualification:

[source,java]
----
package org.somelib;
public class LibClass {
    public static Object use(String name) throws Exception {
        return getUserClass(name).newInstance();
    }
    private Class<?> getUserClass(String name) throws ClassNotFoundException {
        return Class.forName(name);
    }
}
----

This does not work properly in Jenkins because the library +org.somelib+ might be defined in plugin A,
while the user class is defined in plugin B depending on A.
+Class.forName(String)+ uses the _calling class_ (+LibClass+) to determine the initiating +ClassLoader+;
since plugin A cannot load classes from plugin B, this will result in a +ClassNotFoundException+.

Other libraries try to work around the issue as follows:

[source,java]
----
package org.somelib;
public class LibClass {
    public static Object use(String name) throws Exception {
        return getUserClass(name).newInstance();
    }
    private Class<?> getUserClass(String name) throws ClassNotFoundException {
        return Class.forName(name, true, Thread.currentThread().getContextClassLoader());
    }
}
----

This also fails by default in Jenkins, since the +contextClassLoader+ can see only Jenkins core (not even plugin A, much less B).
Jenkins plugin code can work around the issue in some cases:

[source,java]
----
package org.jenkinsci.plugins.b;
import org.somelib.LibClass;
class UsesThatLib {
    Object someMethod() {
        Thread t = Thread.currentThread();
        ClassLoader orig = t.getContextClassLoader();
        t.setContextClassLoader(UsesThatLib.class.getClassLoader());
        try {
            return LibClass.use(UsesThatLib.class.getName());
        } finally {
            t.setContextClassLoader(orig);
        }
    }
}
----

(When the particular class loader needed is unclear, +UberClassLoader+ can be used as a fallback,
though this is not as safe since lookups could be ambiguous in case two unrelated plugins both bundled the same library.)

Ultimately however it is a design flaw in the library if it fails to allow clients to directly specify a +ClassLoader+ to use for lookups
(or preregister +Class+ instances for particular names).
Consider patching the library or looking harder for appropriate APIs that already exist.
As an example, +java.io.ObjectInputStream+ (used for deserializing Java objects) by default uses a complicated algorithm to guess at a +ClassLoader+,
but you can override +resolveClass+ to remove the need for guessing (as +hudson.remoting.ObjectInputStreamEx+ in fact does).

### Views and other resources

Jenkins plugins normally contain “Stapler views” like +config.jelly+ as well as other resources in +src/main/resources/+.
While you can explicitly load these from Java code:

[source,java]
----
package org.jenkinsci.plugins.a;
public class Alpha {
    /** loads {@code /org/jenkinsci/plugins/a/config.txt} from {@code a.jpi!/WEB-INF/lib/a.jar} */
    static URL config() throws IOException {
        return Alpha.class.getResource("config.txt");
    }
}
----

normally such resources would be loaded on your behalf, for example by the convention of Jenkins looking for a view.
In such cases the lookup passes through +UberClassLoader+, so your resource path (+/org/jenkinsci/plugins/a/config.txt+)
had better be globally unique.

+Messages.properties+ used for localization is a little different,
since this is actually compiled to +Messages.class+ during the build,
and thus behaves like any other Java class referred to statically from your plugin code:

[source,java]
----
package org.jenkinsci.plugins.a;
public class Alpha {
    /** compiled from {@code /org/jenkinsci/plugins/a/Messages.properties#Alpha.message} */
    static String message() throws IOException {
        return Messages.Alpha_message();
    }
}
----

## Depending on other plugins

Making your plugin depend on other plugins is easy: just declare dependencies in your POM, by hand or using your favorite IDE.

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>org.jenkins-ci.plugins</groupId>
        <artifactId>a</artifactId>
        <version>1.13</version>
    </dependency>
    <dependency>
        <groupId>org.jenkins-ci.plugins</groupId>
        <artifactId>b</artifactId>
        <version>1.6</version>
    </dependency>
</dependencies>
----

The Maven packaging type for Jenkins plugins understands to translate this to the +Plugin-Dependencies+ manifest header,
which will be understood by the Jenkins plugin manager, as well as the update center and other tools.

The Maven compiler plugin similarly understands that +a-1.13.jar+ and +b-1.6.jar+ should be added to your classpath when building your plugin.

### Extensions and inversion of control

A “service locator” pattern is used throughout Jenkins for modularity and extensibility.
For example, if a plugin (or core) defines an API

[source,java]
----
package org.jenkinsci.plugins.someapi;
import hudson.ExtensionPoint;
public interface Checker extends ExtensionPoint {
    boolean doesThisSeemOK(String input);
}
----

then another plugin may declare a dependency on that API

[source,xml]
----
<dependency>
    <groupId>org.jenkins-ci.plugins</groupId>
    <artifactId>someapi</artifactId>
    <version>1.0</version>
</dependency>
----

and add an extension:

[source,java]
----
package org.jenkinsci.plugins.somethingelse;
import hudson.Extension;
import org.jenkinsci.plugins.someapi.Checker;
@Extension
public class MyChecker implements Checker {
    @Override
    public boolean doesThisSeemOK(String input) {
        return !input.contains("/");
    }
}
----

Now any code able to link against +someapi+ can use those implementations;
most commonly this is done inside the same API plugin:

[source,java]
----
package org.jenkinsci.plugins.someapi;
import hudson.ExtensionList;
class RunsChecks {
    static boolean allFine(String input) {
        for (Checker c : ExtensionList.lookup(Checker.class)) {
            if (!c.doesThisSeemOK(input)) {
                return false;
            }
        }
        return true;
    }
}
----

It is important to understand that while +MyChecker+ needs to link against +Checker+, mandating that +dependency+,
+RunsChecks+ does _not_ need to be able to link against +MyChecker+ (or any of the other implementations).
While the local variable +c+’s implementation class might be in the +somethingelse+ plugin,
it need only care about the _declared type_ +Checker+.

## Bundling third-party libraries

Sometimes plugins need to use Java libraries beyond what is available in the Java Platform and Jenkins itself.
For example, a plugin connecting to a particular service might use a Java SDK provided by the vendor.

Doing this is very easy—in principle.
Simply declare a Maven dependency on that library:

[source,xml]
----
<dependency>
    <groupId>com.yoyodyne.cloud</groupId>
    <artifactId>cloud-access-sdk</artifactId>
    <version>1.0</version>
</dependency>
----

(This assumes that the library is available in Maven Central.
If not, it is possible to upload artifacts to the Jenkins Artifactory repository for use from plugins.
Ask on the developer list for help.
Do *not* attempt to keep such binaries in source control.)

Besides making SDK classes (say, +com.yoyodyne.cloud.*+) available during compilation,
the +maven-hpi-plugin+ used to create Jenkins plugins will notice that this is dependency is not itself a Jenkins plugin,
and instead _bundle_ it inside +yourplugin.hpi+ as +WEB-INF/lib/cloud-access-sdk-1.0.jar+.

At runtime, the plugin class loader will load classes from +WEB-INF/lib/cloud-access-sdk-1.0.jar+,
just as it would from +WEB-INF/lib/yourplugin.jar+ (your plugin’s own code, from +src/main/java/+ and +src/main/resources/+).
Thus your plugin’s classes can refer to classes in that library.
Other plugins depending on your plugin can, too.

### Checking +WEB-INF/lib/*.jar+ for junk

Beware that Maven dependencies include _all transitive_ dependencies.
This can lead to unexpected results when bundling libraries.
For example, the POM for +com.yoyodyne.cloud:cloud-access-sdk+ might declare that it needs +commons-net:commons-net:3.5+.
Your plugin will thus wind up bundling +commons-net-3.5.jar+ as well.
If you are not careful, +WEB-INF/lib/+ may fill up with megabytes of stuff which is not actually used.

### Using library wrapper plugins

TODO suggest inclusion of major version in artifactId

### +pluginFirstClassLoader+ and its discontents

TODO

### Shading

TODO

## +@Restricted+ annotations

TODO

## Jenkins modules

TODO

## +JenkinsRule+ vs. +acceptance-test-harness+ class loading

TODO

## Overridable core components

TODO
