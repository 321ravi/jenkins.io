---
layout: documentation
title: Using Jenkins to build a Python application with PyInstaller
section: doc
---

:toc:
:toclevels: 3
:imagesdir: /doc/book/resources

This tutorial shows you how to use Jenkins to orchestrate building a simple
Python application with http://www.pyinstaller.org/[PyInstaller].

If you are a Python developer who is new to CI/CD concepts, or you might be
familiar with these concepts but don't know how to implement building your
application using Jenkins, then this tutorial is for you.

The simple Python application (which you'll obtain from a sample repository on
GitHub) is an "add" function that outputs the addition of two values. If at
least one of the values happens to be a string, the "add" function treats both
values as a string and instead concatenates them together. The add function is
accompanied by a set of unit tests to check that the function works as expected.

*Duration:* This tutorial takes 20-40 minutes to complete (assuming you've
already met the <<prerequisites,prerequisites>> below). The exact duration will
depend on the speed of your machine and whether or not you've already
<<run-jenkins-in-docker,run Jenkins in Docker>> from link:..[another
introductory tutorial].

You can stop this tutorial at any point in time and continue from where you left
off.

If you've already run though link:..[another tutorial], you can skip the
<<prerequisites,Prerequisites>> and <<run-jenkins-in-docker,Run Jenkins in
Docker>> sections below and proceed on to <<fork-sample-repository,forking the
sample repository>>. (Just ensure you have
link:https://git-scm.com/downloads[Git] installed locally.) If you need to
restart Jenkins, simply follow the restart instructions in
<<stopping-and-restarting-jenkins,Stopping and restarting Jenkins>> and then
proceed on.

include::doc/tutorials/_prerequisites.adoc[]
** link:https://git-scm.com/downloads[Git] and optionally
   link:https://desktop.github.com/[GitHub Desktop]

include::doc/tutorials/_run-jenkins-in-docker.adoc[]


[[fork-sample-repository]]
=== Fork and clone the sample repository on GitHub

Obtain the simple "add" Python application from GitHub, by forking the sample
repository of the application's source code into your own GitHub account and
then cloning this fork locally.

. Ensure you are signed in to your GitHub account. If you don't yet have a
  GitHub account, sign up for a free one on the https://github.com/[GitHub
  website].
. Fork the
  https://github.com/jenkins-docs/simple-python-pyinstaller-app[`simple-python-pyinstaller-app`]
  on GitHub into your local GitHub account. If you need help with this process,
  refer to the https://help.github.com/articles/fork-a-repo/[Fork A Repo]
  documentation on the GitHub website for more information.
. Begin cloning your forked `simple-python-pyinstaller-app` repository (on
  GitHub) locally to your machine by opening up a terminal/command line window
  to the directory in which the repository will be cloned. This tutorial assumes
  that `simple-python-pyinstaller-app` will be cloned within the following
  directories on these platforms, which you should `cd` into now:
* macOS - `/Users/<your-username>/Documents/GitHub`
* Linux - `/home/<your-username>/GitHub`
* Windows - `C:\Users\<your-username>\Documents\GitHub`

+
where `<your-username>` is your user account's name on your operating system.

+
*Note:*

** On a Windows machine, use a Git bash command line window (as opposed to the
   usual Microsoft command prompt).
** Alternatively, and in particular if you have the GitHub Desktop app installed
   on your machine, in GitHub, you can click the green *Clone or download*
   button on your forked repository and follow the instructions to clone the
   repository locally. If you use GitHub Desktop, you can omit the following
   step.

+
. Run the following command to continue/complete cloning your forked repo: +
  `git clone https://github.com/YOUR-GITHUB-ACCOUNT-NAME/simple-python-pyinstaller-app` +
  where `YOUR-GITHUB-ACCOUNT-NAME` is the name of your GitHub account.


=== Create your Pipeline project in Jenkins

. Go back to Jenkins, log in again if necessary and click *create new jobs*
  under *Welcome to Jenkins!* +
  *Note:* If you don't see this, click *New Item* at the top left.
. In the *Enter an item name* field, specify the name for your new Pipeline
  project (e.g. `simple-python-pyinstaller-app`).
. Scroll down and click *Pipeline*, then click *OK* at the end of the page.
. ( _Optional_ ) On the next page, specify a brief description for your Pipeline
  in the *Description* field (e.g. `An entry-level Pipeline demonstrating how to
  use Jenkins to build a simple Python application with PyInstaller.`)
. Click the *Pipeline* tab at the top of the page to scroll down to the
  *Pipeline* section.
. From the *Definition* field, choose the *Pipeline script from SCM* option.
  This option instructs Jenkins to obtain your Pipeline from Source Control
  Management (SCM), which will be your locally cloned Git repository.
. From the *SCM* field, choose *Git*.
. In the *Repository URL* field, specify the directory path of your locally
  cloned repository <<fork-and-clone-the-sample-repository-on-github,above>>,
  which is from your user account/home directory on your host machine, mapped to
  the `/home` directory of the Jenkins/Blue Ocean container - i.e.
* For macOS - `/home/Documents/GitHub/simple-python-pyinstaller-app`
* For Linux - `/home/GitHub/simple-python-pyinstaller-app`
* For Windows - `/home/Documents/GitHub/simple-python-pyinstaller-app`
. Click *Save* to save your new Pipeline project. You're now ready to begin
  creating your `Jenkinsfile`, which you'll be checking into your locally cloned
  Git repository.


=== Create your initial Pipeline as a Jenkinsfile

You're now ready to create your Pipeline that will automate building your Python
application with PyInstaller in Jenkins. Your Pipeline will be created as a
`Jenkinsfile`, which will be committed to your locally cloned Git repository
(`simple-python-pyinstaller-app`).

This is the foundation of "Pipeline-as-Code", which treats the continuous
delivery pipeline a part of the application to be versioned and reviewed like
any other code. Read more about Pipeline and what a Jenkinsfile is in the
link:/doc/book/pipeline[Pipeline] and link:/doc/book/pipeline/jenkinsfile[Using
a Jenkinsfile] sections of the User Handbook.

First, create an initial Pipeline with a "Build" stage that executes the first
part of the entire production process for your application. This "Build" stage
downloads a Python Docker image and runs it as a Docker container, which in turn
compiles your simple Python application into byte code.

. Using your favorite text editor or IDE, create and save new text file with the
  name `Jenkinsfile` at the root of your local `simple-python-pyinstaller-app`
  Git repository.
. Copy the following Declarative Pipeline code and paste it into your empty
  `Jenkinsfile`:
+
[source,groovy]
----
pipeline {
    agent none // <1>
    stages {
        stage('Build') { // <2>
            agent {
                docker {
                    image 'python:3.4-slim' // <3>
                }
            }
            steps {
                sh 'python -m py_compile sources/add2vals.py' // <4>
            }
        }
    }
}
----
<1> The link:/doc/book/pipeline/syntax#agent[`agent`] section with the `none`
parameter specified at the top of this Pipeline code block means that no global
agent will be allocated for the entire Pipeline's execution and that each
link:/doc/book/pipeline/syntax/#stage[`stage`] directive must specify its own
`agent` section.
<2> Defines a link:/doc/book/pipeline/syntax/#stage[`stage`] (directive) called
`Build` that appears on the Jenkins UI.
<3> This `image` parameter (of the link:/doc/book/pipeline/syntax#agent[`agent`]
section's `docker` parameter) downloads the
https://hub.docker.com/_/python/[`python:3.4-slim` Docker image] (if it's not
already available in your Docker host) and runs this image as a separate
container. This means that:
* You'll have separate Jenkins/Blue Ocean and Python containers running locally
  in Docker.
* The Python container becomes the link:/doc/book/glossary/#agent[agent] that
  Jenkins uses to run the `Build` stage of your Pipeline project. However,
  this container is short-lived - its lifespan is only that of the duration of
  your `Build` stage's execution.
<4> This `sh` step (of the link:/doc/book/pipeline/syntax/#steps[`steps`]
section) runs the Python command to compile your application into a byte code
file (with a `.pyc` extension), which is placed into the local
`sources/__pycache__` directory (i.e. within the
`/var/jenkins_home/workspace/simple-python-pyinstaller-app` directory in the
Jenkins/Blue Ocean container).
. Save your amended `Jenkinsfile` and commit it to your local
  `simple-python-pyinstaller-app` Git repository. E.g. Within the
  `simple-python-pyinstaller-app` directory, run the commands: +
  `git add .` +
  then +
  `git commit -m "Add initial Jenkinsfile"`
. Go back to Jenkins again, log in again if necessary and click *Open Blue
  Ocean* on the left to access Jenkins's Blue Ocean interface.
. In the *This job has not been run* message box, click *Run*, then quickly
  click the *OPEN* link which appears briefly at the lower-right to see Jenkins
  running your Pipeline project. If you weren't able to click the *OPEN* link,
  click the row on the main Blue Ocean interface to access this feature. +
  *Note:* You may need to wait several minutes for this first run to complete.
  After making a clone of your local `simple-python-pyinstaller-app` Git
  repository itself, Jenkins:
.. Initially queues the project to be run on the agent.
.. Downloads the Python Docker image and runs it in a container on Docker.
+
[.boxshadow]
image:tutorials/java-maven-01-downloading-maven-docker-image.png[alt="Downloading
Maven Docker image",width=100%]
.. Runs the `Build` stage (defined in the `Jenkinsfile`) on the Python
   container. During this time, Python uses the `py_compile` module to compile
   your Python application's code into byte code, which will be stored in the
   local `sources/__pycache__` directory (within the Jenkins home directory).
[.boxshadow]
image:tutorials/java-maven-02-initial-pipeline-downloading-maven-artifacts.png[alt="Downloading
Maven artifacts",width=100%]

+
The Blue Ocean interface turns green if Jenkins compiled your Python application
successfully.
[.boxshadow]
image:tutorials/java-maven-03-initial-pipeline-runs-successfully.png[alt="Initial
Pipeline runs successfully",width=100%]
. Click the *X* at the top-right to return to the main Blue Ocean interface.
+
[.boxshadow]
image:tutorials/java-maven-04-main-blue-ocean-interface.png[alt="Main Blue Ocean
interface",width=100%]


=== Add a test stage to your Pipeline

. Go back to your text editor/IDE and ensure your `Jenkinsfile` is open.
. Copy and paste the following Declarative Pipeline syntax immediately under the
  `Build` stage of your `Jenkinsfile`:
+
[source,groovy]
----
        stage('Test') {
            agent {
                docker {
                    image 'python:3.4-slim'
                }
            }
            steps {
                sh 'python sources/test_calc.py'
            }
        }
----
so that you end up with:
+
[source,groovy]
----
pipeline {
    agent none
    stages {
        stage('Build') {
            agent {
                docker {
                    image 'python:3.4-slim'
                }
            }
            steps {
                sh 'python -m py_compile sources/add2vals.py'
            }
        }
        stage('Test') { // <1>
            agent {
                docker {
                    image 'python:3.4-slim' // <2>
                }
            }
            steps {
                sh 'python sources/test_calc.py' // <3>
            }
        }
    }
}
----
<1> Defines a link:/doc/book/pipeline/syntax/#stage[`stage`] (directive) called
`Test` that appears on the Jenkins UI.
<2> This `image` parameter (of the link:/doc/book/pipeline/syntax#agent[`agent`]
section's `docker` parameter) runs the previously downloaded
https://hub.docker.com/_/python/[`python:3.4-slim` Docker image] as a separate
container, such that:
* You'll have separate Jenkins/Blue Ocean and Python containers running locally
  in Docker again.
* The Python container becomes the link:/doc/book/glossary/#agent[agent] that
  Jenkins uses to run the `Test` stage of your Pipeline project. This
  container's lifespan lasts the duration of your `Test` stage's execution.
<3> This `sh` step (of the link:/doc/book/pipeline/syntax/#steps[`steps`]
section) executes the Python command to run `sources/test_calc.py`, which runs a
set of unit tests (defined in `test_calc.py`) on your simple Python application.
. Save your amended `Jenkinsfile` and commit it to your local
  `simple-python-pyinstaller-app` Git repository. E.g. Within the
  `simple-python-pyinstaller-app` directory, run the commands: +
  `git stage .` +
  then +
  `git commit -m "Add 'Test' stage"`
. Go back to Jenkins again, log in again if necessary and ensure you've accessed
  Jenkins's Blue Ocean interface.
. Click *Run* at the top left, then quickly click the *OPEN* link which appears
  briefly at the lower-right to see Jenkins running your amended Pipeline
  project. If you weren't able to click the **OPEN** link, click the _top_ row
  on the Blue Ocean interface to access this feature. +
  *Note:* You'll notice from this run that Jenkins no longer needs to download
  the Python Docker image. Instead, Jenkins only needs to run new containers
  from the initially downloaded Python image. Therefore, running your Pipeline
  this subsequent time should be much faster. +
  If your amended Pipeline ran successfully, here's what the Blue Ocean
  interface should look like. Notice the additional "Test" stage. You can click
  on the previous "Build" stage circle to access the output from that stage.
[.boxshadow]
image:tutorials/java-maven-11-test-stage-runs-successfully-with-output.png[alt="Test
stage runs successfully (with output)",width=100%]
. Click the *X* at the top-right to return to the main Blue Ocean interface.


=== Add a final deliver stage to your Pipeline

. Go back to your text editor/IDE and ensure your `Jenkinsfile` is open.
. Copy and paste the following Declarative Pipeline syntax immediately under the
  `Test` stage of your `Jenkinsfile`:
+
[source,groovy]
----
        stage('Deliver') {
            agent {
                docker {
                    image 'cdrx/pyinstaller-linux'
                }
            }
            steps {
                sh 'pyinstaller --onefile sources/add2vals.py'
            }
        }
----
so that you end up with:
+
[source,groovy]
----
pipeline {
    agent none
    stages {
        stage('Build') {
            agent {
                docker {
                    image 'python:3.4-slim'
                }
            }
            steps {
                sh 'python -m py_compile sources/add2vals.py'
            }
        }
        stage('Test') {
            agent {
                docker {
                    image 'python:3.4-slim'
                }
            }
            steps {
                sh 'python sources/test_calc.py'
            }
        }
        stage('Deliver') { // <1>
            agent {
                docker {
                    image 'cdrx/pyinstaller-linux' // <2>
                }
            }
            steps {
                sh 'pyinstaller --onefile sources/add2vals.py' // <3>
            }
        }
    }
}
----
<1> Defines a link:/doc/book/pipeline/syntax/#stage[`stage`] (directive) called
`Deliver` that appears on the Jenkins UI.
<2> This `image` parameter (of the link:/doc/book/pipeline/syntax#agent[`agent`]
section's `docker` parameter) downloads the
https://hub.docker.com/r/cdrx/pyinstaller-linux/[`cdrx/pyinstaller-linux` Docker
image] (if it's not already available in your Docker host) and runs this image
as a separate container. This means that:
* You'll have separate Jenkins/Blue Ocean and PyInstaller (for Linux) containers
  running locally in Docker.
* The PyInstaller container becomes the link:/doc/book/glossary/#agent[agent]
  that Jenkins uses to run the `Deliver` stage of your Pipeline project. This
  container's lifespan lasts the duration of your `Deliver` stage's execution.
<2> This `sh` step (of the link:/doc/book/pipeline/syntax/#steps[`steps`]
section) executes the `pyinstaller` command (in the PyInstaller container) on
your simple Python application. This bundles your `add2vals.py` Python
application into a single-file executable (via the +
`--onefile` option). Although this step consists of a single command, as a
general principle, it's a good idea to keep your Pipeline code (i.e. the
`Jenkinsfile`) as tidy as possible and place more complex build steps
(particularly for stages consisting of 2 or more steps) into separate shell
script files like the `deliver.sh` file. This ultimately makes maintaining your
Pipeline code easier, especially if your Pipeline gains more complexity.
. Save your amended `Jenkinsfile` and commit it to your local
  `simple-python-pyinstaller-app` Git repository. E.g. Within the
  `simple-python-pyinstaller-app` directory, run the commands: +
  `git stage .` +
  then +
  `git commit -m "Add 'Deliver' stage"`
. Go back to Jenkins again, log in again if necessary and ensure you've accessed
  Jenkins's Blue Ocean interface.
. Click *Run* at the top left, then quickly click the *OPEN* link which appears
  briefly at the lower-right to see Jenkins running your amended Pipeline
  project. If you weren't able to click the **OPEN** link, click the _top_ row
  on the Blue Ocean interface to access this feature. +
  If your amended Pipeline ran successfully, here's what the Blue Ocean
  interface should look like. Notice the additional "Deliver" stage. Click on
  the previous "Test" and "Build" stage circles to access the outputs from those
  stages.
+
[.boxshadow]
image:tutorials/java-maven-21-deliver-stage-runs-successfully.png[alt="Deliver
stage runs successfully",width=100%]

+
Here's what the output of the "Deliver" stage should look like, showing you the
execution results of your Java application at the end.
[.boxshadow]
image:tutorials/java-maven-22-deliver-stage-output-only.png[alt="Deliver stage
output only",width=100%]
. Click the *X* at the top-right to return to the main Blue Ocean interface,
  which lists your previous Pipeline runs in reverse chronological order.
[.boxshadow]
image:tutorials/java-maven-23-main-blue-ocean-interface-with-all-previous-runs-displayed.png[alt="Main
Blue Ocean interface with all previous runs displayed",width=100%]


=== Wrapping up

Well done! You've just used Jenkins to build a simple Java application with
Maven!

The "Build", "Test" and "Deliver" stages you created above are the basis for
building more complex Java applications with Maven in Jenkins, as well as Java
and Maven applications that integrate with other technology stacks.

Because Jenkins is extremely extensible, it can be modified and configured to
handle practically any aspect of build orchestration and automation.

To learn more about what Jenkins can do, check out:

* The link:/doc/tutorials[Tutorials overview] page for other introductory
  tutorials.
* The link:/doc/book[User Handbook] for more detailed information about using
  Jenkins, such as link:/doc/book/pipeline[Pipelines] (in particular
  link:/doc/book/pipeline/syntax[Pipeline syntax]) and the
  link:/doc/book/blueocean[Blue Ocean] interface.
* The link:/node[Jenkins blog] for the latest events, other tutorials and
  updates.

include::doc/_feedback-footer.adoc[]

////
Hide this warning due to temporary addition to 'mvn jar:jar install:install'
fix implemented.
*Warning:* It's possible that since Maven downloads artifacts during this final
`Deliver` stage, Maven will attempt to run some of the other commands further
down the `sh` step before the artifacts have finished downloading. This will
cause the build to fail. If you notice the build failing the first time, run
the Pipeline project again and it should succeed.
////
